<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2013.1.4 (Build 801)" ts="2017-10-31 08:37:03">
<Class name="Demo.BabylonJSRTS.game">
<Description>
Пример использования BabylonJS в Cache`</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>%CSP.Page</Super>
<TimeChanged>64587,30807.301288</TimeChanged>
<TimeCreated>64586,75076.372676</TimeCreated>

<Method name="ExecFrag">
<Description>
Метод разбики исходного текста на Cache` код и HTML текст</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>SrcCode="",Beg="",End=""</FormalSpec>
<Implementation><![CDATA[     q:SrcCode=""   q:Beg=""    q:End=""    for ExecFragInd=1:1:$l(SrcCode,End){  s tmp=$p(SrcCode,End,ExecFragInd)   s Html=$p(tmp,Beg,1)     s Code=$p(tmp,Beg,2)   w Html   TRY {     x Code    } CATCH ErrorHandle {    zw ErrorHandle  }    }
]]></Implementation>
</Method>

<Method name="DrawXdata">
<ClassMethod>1</ClassMethod>
<FormalSpec>Name={##This_":XDataContet"}</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
   if $l(Name,":")=1,$e(Name,1,2)'=".."{  s Name=".."_Name  }
   if $e(Name,1,2)=".." {  s ClassName=##This,XdataName=$e(Name,3,$l(Name))
   }else{                  s ClassName=$p(Name,":",1),XdataName=$p(Name,":",2)  }
   s gl="^oddDEF("""_ClassName_""",""x"","""_XdataName_""",21)"  
   s FragOnPageInd=""  f {  s FragOnPageInd=$o(@gl@(FragOnPageInd))  q:FragOnPageInd=""  continue:FragOnPageInd=1  q:FragOnPageInd=@gl      d ..ExecFrag(@gl@(FragOnPageInd),"/*(",")*/")     w $c(13,10)  }
]]></Implementation>
</Method>

<Parameter name="DstName">
<Default>Demo.BabylonJSRTS.game.cls</Default>
</Parameter>

<Parameter name="FileName">
<Default>C:\AppServ\www\333\game.htm</Default>
</Parameter>

<Parameter name="Rashirenie">
<Default>htm</Default>
</Parameter>

<Parameter name="SrcName">
<Default>game.htm</Default>
</Parameter>

<Parameter name="isBinFile">
<Default>0</Default>
</Parameter>

<Method name="OnPage">
<Description>
30/10/2017  20:51:16</Description>
<ClassMethod>1</ClassMethod>
<Language>cache</Language>
<ReturnType>%Library.Status</ReturnType>
<Implementation><![CDATA[
     d ..DrawXdata("XDataContet")
     Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnPreHTTP">
<ClassMethod>1</ClassMethod>
<ReturnType>%Library.Boolean</ReturnType>
<Implementation><![CDATA[
    Do %response.SetHeader("Content-Type","text/html") 
    if $d(%request.Data("download",1))
    {
       Do %response.SetHeader("Content-Disposition: attachment; filename=","C:\AppServ\www\333\game.htm") 
    }
    q 1
]]></Implementation>
</Method>

<XData name="XDataContet">
<Data><![CDATA[
<data>
    <head>
        <title>Using babylon.js - Test page</title>
        <script language="JavaScript" type="text/javascript" src="HTML.CacheLib.cls"></script>
        <script src="Demo.BabylonJSRTS.js.babylon.cls"></script>
        <script src="Demo.BabylonJSRTS.js.RtsCamera.cls"></script>
    </head>
    <body
        style="overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;">
        <canvas id="renderCanvas"
                oncontextmenu="retrun false;" 
                style="
                width: 30%;
                height: 30%;
                touch-action: none;"
                ></canvas>

        <script>
            document.oncontextmenu = function (){return false;};
            var impact;
            var camera;
            var Zemlya;
            var canvas = document.getElementById("renderCanvas");
            var engine = new BABYLON.Engine(canvas, true);
            var scene = new BABYLON.Scene(engine);
            // Наполняем сцену событиями
            createScene(scene); 
            // Перерисовка сцены в постоянном цикле
            engine.runRenderLoop(function () { scene.render(); });
            // Масшабируем сцены под любые разрешения при изменении окна
            window.addEventListener("resize", function () { engine.resize(); })
           
            var meshesColliderList = [];
            for (var i = 1; i < scene.meshes.length; i++) {
                if (scene.meshes[i].checkCollisions){
                   if(scene.meshes[i].isVisible === false) {
                      scene.meshes[i].setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, {mass: 0, friction: 0.5, restitution: 0.7});
                      meshesColliderList.push(scene.meshes[i]);
                   }
                }
            }
        </script>
    </body>
</data>
]]></Data>
</XData>

<Method name="createScene">
<Description>
функция создания сцены. И окрашиваем её в синий цвет</Description>
<FormalSpec>scene</FormalSpec>
<Language>javascript</Language>
<ReturnType>%String</ReturnType>
<WebMethod>1</WebMethod>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
   // setup environment
   var light0 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, -10, 20), scene);
  camera = new BABYLON.ArcRotatePanCamera(  "ArcRotatePanCamera", 0, 0, -80, BABYLON.Vector3.Zero(), scene );
  camera.setPosition(new BABYLON.Vector3(-10, 10, -10));
  camera.setTarget(BABYLON.Vector3.Zero());
  camera.attachControl(canvas, true);

  impact = BABYLON.Mesh.CreateBox("box", 1, scene);
  impact.position = new BABYLON.Vector3(0, 0, 0);

  var impact2 = BABYLON.Mesh.CreateBox("box1", 1, scene);
  impact2.position = new BABYLON.Vector3(10, 0, 10);

  Zemlya = BABYLON.Mesh.CreatePlane("Earth", 4000.0, scene);
  Zemlya.material = new BABYLON.StandardMaterial("wallMat", scene);
  Zemlya.material.emissiveColor = new BABYLON.Color3(0.5, 1, 0.5);
  Zemlya.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);
  /// scene.getMeshByName("box");
  /// Обработка событий мышки
  scene.onPointerDown = onPointerDown
  /// Ограничеваем перемещение камеры 
  scene.registerBeforeRender(beforeRenderFunction);
  return scene;
]]></Implementation>
</Method>

<Method name="beforeRenderFunction">
<Description>
Ограничевает перемещение камеры</Description>
<Language>javascript</Language>
<WebMethod>1</WebMethod>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
   // Camera
   if (camera.beta < 0.1) {
       camera.beta = 0.1;
   } else if (camera.beta > (Math.PI / 2) * 0.9) {
       camera.beta = (Math.PI / 2) * 0.9;
   }
   if (camera.radius > 100) {
       camera.radius = 100;
   }
   if (camera.radius < 5) {
       camera.radius = 5;
   }
]]></Implementation>
</Method>

<Method name="onPointerDown">
<Description>
Обработка событий мышки</Description>
<FormalSpec>event,pickResult</FormalSpec>
<Language>javascript</Language>
<WebMethod>1</WebMethod>
<ClientMethod>1</ClientMethod>
<Implementation><![CDATA[
	  var x = pickResult.pickedPoint.x;
      var z = pickResult.pickedPoint.z;
      var y = pickResult.pickedPoint.y;
      if (event.button == 0) {
      if (pickResult.hit) {
           //var indices = pickResult.pickedMesh.getOwnPropertyNames();
           if (pickResult.pickedMesh.name != "Earth") {
           //pickResult.pickedSprite.angle += 0.5;
               impact.position.x = x;
               impact.position.z = z;
               impact.position.y = y;
               //   Найти объект по имени
               //   var box_I_made = scene.getMeshByName("box");
               //   box_I_made.rotation.y = Math.PI / 2;
             }
          }
      }
      if (event.button == 2) {
	      
      }
]]></Implementation>
</Method>
</Class>
</Export>
